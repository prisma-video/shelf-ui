type movieNFT = 
 service {
   _exists: (TokenIndex) -> (bool);
   _isApprovedOrOwner: (principal, TokenIndex) -> (bool);
   _transfer: (principal, principal, TokenIndex) -> ();
   _updateBalance: (principal, int) -> (Result);
   acceptCycles: () -> ();
   availableCycles: () -> (nat) query;
   balanceOf: (principal) -> (nat) query;
   getApproved: (TokenIndex) -> (Result_1);
   getCaller: () -> (principal) query;
   getMinter: () -> (principal) query;
   getNFTsOfOwner: () -> (Result_2) query;
   getOwners: () -> (vec record {
                           TokenIndex;
                           principal;
                         }) query;
   getTokens: () -> (vec record {
                           TokenIndex;
                           TokenMetadata;
                         }) query;
   mintMovieNFT: (principal, TokenMetadata) -> (TokenIndex);
   ownerOf: (TokenIndex) -> (Result_1) query;
   setMinter: (principal) -> ();
   tokenOfOwnerByIndex: (principal, nat) -> (opt TokenIndex) query;
   totalSupply: () -> (Result) query;
   transferFrom: (principal, principal, TokenIndex) -> ();
 };
type TokenMetadata = 
 record {
   description: text;
   name: text;
   properties:
    record {
      internal_id: text;
      metadata_version: nat;
      original_owner: principal;
      previous_metadata: text;
      shipment_id: text;
      title: text;
    };
 };
type TokenIndex__1 = nat32;
type TokenIndex = nat32;
type Result_2 = 
 variant {
   err: CommonError;
   ok: vec record {
             TokenIndex;
             TokenMetadata;
           };
 };
type Result_1 = 
 variant {
   err: CommonError;
   ok: principal;
 };
type Result = 
 variant {
   err: CommonError;
   ok: Balance;
 };
type CommonError = 
 variant {
   InvalidToken: TokenIndex__1;
   Other: text;
 };
type Balance = nat;
service : (principal) -> movieNFT
